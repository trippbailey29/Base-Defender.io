<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>2D IO Tank Defense Game</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden; background: #222;
    font-family: Arial, sans-serif; color: white;
    user-select: none;
  }
  canvas {
    display: block;
    background: #111;
    margin: 0 auto;
    border: 2px solid #555;
  }
  #startScreen, #gameOverScreen {
    position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    background: #333;
    padding: 20px 30px;
    border-radius: 10px;
    text-align: center;
  }
  #startScreen button, #upgradeBtn, #playBtn, #restartBtn {
    margin: 10px 5px;
    padding: 10px 20px;
    font-size: 16px;
    cursor: pointer;
    border: none;
    border-radius: 5px;
  }
  #upgradeBtn:disabled {
    background: #555;
    cursor: not-allowed;
  }
  .color-option {
    display: inline-block;
    width: 40px; height: 40px;
    margin: 10px 10px 0 10px;
    border-radius: 5px;
    cursor: pointer;
    border: 3px solid transparent;
  }
  .color-option.selected {
    border-color: yellow;
  }
  #ui {
    position: absolute; top: 10px; left: 10px;
    background: rgba(0,0,0,0.6);
    padding: 10px 15px;
    border-radius: 8px;
    font-size: 18px;
    user-select: none;
  }
</style>
</head>
<body>

<div id="startScreen">
  <h2>Choose Your Tank Color</h2>
  <div>
    <div class="color-option" id="colorBlue" style="background:#3b82f6;" title="Press 1 for Blue"></div>
    <div class="color-option" id="colorRed" style="background:#ef4444;" title="Press 2 for Red"></div>
    <div class="color-option" id="colorGreen" style="background:#22c55e;" title="Press 3 for Green"></div>
  </div>
  <button id="playBtn" disabled>Play</button>
  <p style="font-size: 14px; margin-top: 10px;">Use keys 1, 2, or 3 to select color</p>
</div>

<div id="gameOverScreen" style="display:none;">
  <h2>Game Over!</h2>
  <p id="finalScore">Your Score: 0</p>
  <button id="restartBtn">Restart</button>
</div>

<div id="ui" style="display:none;">
  <div>Base HP: <span id="baseHP">100</span></div>
  <div>Score: <span id="score">0</span></div>
  <button id="upgradeBtn">Upgrade Base</button>
</div>

<canvas id="gameCanvas" width="800" height="600"></canvas>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  // UI elements
  const startScreen = document.getElementById('startScreen');
  const gameOverScreen = document.getElementById('gameOverScreen');
  const finalScore = document.getElementById('finalScore');
  const restartBtn = document.getElementById('restartBtn');
  const upgradeBtn = document.getElementById('upgradeBtn');
  const baseHPSpan = document.getElementById('baseHP');
  const scoreSpan = document.getElementById('score');
  const playBtn = document.getElementById('playBtn');

  // Color options and selection
  const colorOptions = {
    blue: '#3b82f6',
    red: '#ef4444',
    green: '#22c55e',
  };
  let tankColor = null;

  // Tank size
  const TANK_SIZE = 30;
  const BASE_RADIUS = 50;
  const ENEMY_SIZE = 25;
  const BULLET_SIZE = 8;
  const BASE_MAX_LEVEL = 5;

  let enemies = [];
  let bullets = [];
  let keys = {};
  let mouse = { x: 0, y: 0, down: false };
  let score = 0;
  let gameRunning = false;
  let lastEnemySpawn = 0;
  let enemySpawnInterval = 2000;

  // Base class
  class Base {
    constructor(x, y) {
      this.x = x;
      this.y = y;
      this.radius = BASE_RADIUS;
      this.maxHP = 100;
      this.hp = 100;
      this.level = 1;
      this.upgradeCost = 5;
      this.defenseDamage = 1;
    }
    upgrade() {
      if (score >= this.upgradeCost && this.level < BASE_MAX_LEVEL) {
        score -= this.upgradeCost;
        this.level++;
        this.maxHP += 50;
        this.hp = this.maxHP;
        this.upgradeCost += 5;
        this.defenseDamage += 1;
        updateUI();
      }
    }
    update(deltaTime) {
      // Base attacks enemies near it automatically
      enemies.forEach(enemy => {
        if (!enemy.alive) return;
        const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
        if (dist < this.radius + 20) {
          enemy.takeDamage(this.defenseDamage);
        }
      });
    }
    draw() {
      // Draw base circle
      ctx.fillStyle = '#555';
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
      ctx.fill();

      // Draw base HP bar
      ctx.fillStyle = 'red';
      const hpWidth = (this.hp / this.maxHP) * this.radius * 2;
      ctx.fillRect(this.x - this.radius, this.y + this.radius + 10, hpWidth, 10);

      ctx.strokeStyle = 'black';
      ctx.strokeRect(this.x - this.radius, this.y + this.radius + 10, this.radius * 2, 10);

      // Draw level text
      ctx.fillStyle = 'white';
      ctx.font = '16px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Base Lv ' + this.level, this.x, this.y - this.radius - 10);
    }
  }

  // Player class
  class Player {
    constructor(x, y, color) {
      this.x = x;
      this.y = y;
      this.size = TANK_SIZE;
      this.speed = 4;
      this.color = color;
      this.reloadTime = 400; // ms between shots
      this.lastShot = 0;
      this.angle = 0;
    }
    update(deltaTime) {
      // Movement controls
      if (keys['w'] || keys['arrowup']) this.y -= this.speed;
      if (keys['s'] || keys['arrowdown']) this.y += this.speed;
      if (keys['a'] || keys['arrowleft']) this.x -= this.speed;
      if (keys['d'] || keys['arrowright']) this.x += this.speed;

      // Clamp inside canvas
      this.x = Math.max(this.size/2, Math.min(canvas.width - this.size/2, this.x));
      this.y = Math.max(this.size/2, Math.min(canvas.height - this.size/2, this.y));

      // Aim toward mouse
      this.angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);

      // Shoot if mouse down and reload time passed
      if (mouse.down) {
        const now = performance.now();
        if (now - this.lastShot > this.reloadTime) {
          bullets.push(new Bullet(this.x + Math.cos(this.angle) * this.size/2, this.y + Math.sin(this.angle) * this.size/2, this.angle));
          this.lastShot = now;
        }
      }
    }
    draw() {
      // Draw tank body
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(this.angle);
      ctx.fillStyle = this.color;
      ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);

      // Tank barrel
      ctx.fillStyle = 'black';
      ctx.fillRect(0, -5, this.size, 10);
      ctx.restore();
    }
  }

  // Enemy class
  class Enemy {
    constructor(x, y) {
      this.x = x;
      this.y = y;
      this.size = ENEMY_SIZE;
      this.speed = 1.4 + Math.random() * 0.7;
      this.hp = 30;
      this.alive = true;
      this.color = 'orange';
    }
    update() {
      if (!this.alive) return;
      const angle = Math.atan2(base.y - this.y, base.x - this.x);
      this.x += Math.cos(angle) * this.speed;
      this.y += Math.sin(angle) * this.speed;

      // Damage base if close
      const dist = Math.hypot(this.x - base.x, this.y - base.y);
      if (dist < base.radius) {
        base.hp -= 0.3;
        if (base.hp < 0) base.hp = 0;
      }
    }
    takeDamage(dmg) {
      this.hp -= dmg;
      if (this.hp <= 0) {
        this.alive = false;
        score++;
        updateUI();
      }
    }
    draw() {
      if (!this.alive) return;
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
      ctx.fill();

      // HP bar
      ctx.fillStyle = 'red';
      const hpBarWidth = this.size;
      const hpPercent = this.hp / 30;
      ctx.fillRect(this.x - hpBarWidth/2, this.y - this.size, hpBarWidth * hpPercent, 4);
      ctx.strokeStyle = 'black';
      ctx.strokeRect(this.x - hpBarWidth/2, this.y - this.size, hpBarWidth, 4);
    }
  }

  // Bullet class
  class Bullet {
    constructor(x, y, angle) {
      this.x = x;
      this.y = y;
      this.size = BULLET_SIZE;
      this.speed = 10;
      this.angle = angle;
      this.alive = true;
      this.damage = 15;
    }
    update() {
      if (!this.alive) return;
      this.x += Math.cos(this.angle) * this.speed;
      this.y += Math.sin(this.angle) * this.speed;

      // Out of bounds check
      if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
        this.alive = false;
      }

      // Collision with enemies
      for (const enemy of enemies) {
        if (!enemy.alive) continue;
        const dist = Math.hypot(this.x - enemy.x, this.y - enemy.y);
        if (dist < this.size/2 + enemy.size/2) {
          enemy.takeDamage(this.damage);
          this.alive = false;
          break;
        }
      }
    }
    draw() {
      if (!this.alive) return;
      ctx.fillStyle = 'yellow';
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Utility to update UI
  function updateUI() {
    baseHPSpan.textContent = Math.floor(base.hp);
    scoreSpan.textContent = score;
    upgradeBtn.disabled = score < base.upgradeCost || base.level >= BASE_MAX_LEVEL;
    upgradeBtn.textContent = base.level >= BASE_MAX_LEVEL ? 'Base Max Level' : `Upgrade Base (Cost: ${base.upgradeCost} Score)`;
  }

  // Spawn enemies randomly on edges
  function spawnEnemy() {
    const edge = Math.floor(Math.random() * 4);
    let x, y;
    switch(edge) {
      case 0: x = Math.random() * canvas.width; y = -20; break;      // Top
      case 1: x = canvas.width + 20; y = Math.random() * canvas.height; break;  // Right
      case 2: x = Math.random() * canvas.width; y = canvas.height + 20; break;  // Bottom
      case 3: x = -20; y = Math.random() * canvas.height; break;      // Left
    }
    enemies.push(new Enemy(x, y));
  }

  // Game over function
  function gameOver() {
    gameRunning = false;
    ui.style.display = 'none';
    gameOverScreen.style.display = 'block';
    finalScore.textContent = `Your Score: ${score}`;
  }

  // Reset game
  function resetGame() {
    score = 0;
    enemies = [];
    bullets = [];
    keys = {};
    mouse.down = false;
    base = new Base(canvas.width / 2, canvas.height / 2);
    player = new Player(base.x, base.y, tankColor);
    lastEnemySpawn = 0;
    enemySpawnInterval = 2000;
    updateUI();
    ui.style.display = 'none';
  }

  // Start game
  function startGame() {
    gameRunning = true;
    base = new Base(canvas.width / 2, canvas.height / 2);
    player = new Player(base.x, base.y, tankColor);
    enemies = [];
    bullets = [];
    lastEnemySpawn = 0;
    enemySpawnInterval = 2000;
    score = 0;
    updateUI();
    ui.style.display = 'block';
    requestAnimationFrame(gameLoop);
  }

  // Game loop
  let lastTime = 0;
  function gameLoop(timestamp = 0) {
    if (!gameRunning) return;
    const deltaTime = timestamp - lastTime;
    lastTime = timestamp;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Spawn enemies over time
    if (timestamp - lastEnemySpawn > enemySpawnInterval) {
      spawnEnemy();
      lastEnemySpawn = timestamp;
      if (enemySpawnInterval > 500) enemySpawnInterval -= 20; // Spawn faster gradually
    }

    base.update(deltaTime);
    player.update(deltaTime);
    enemies.forEach(e => e.update());
    bullets.forEach(b => b.update());

    // Remove dead enemies and bullets off screen
    enemies = enemies.filter(e => e.alive || Math.hypot(e.x - base.x, e.y - base.y) < canvas.width);
    bullets = bullets.filter(b => b.alive);

    base.draw();
    player.draw();
    enemies.forEach(e => e.draw());
    bullets.forEach(b => b.draw());

    updateUI();

    if (base.hp <= 0) {
      gameOver();
      return;
    }

    requestAnimationFrame(gameLoop);
  }

  // Input handlers for mouse and touch
  canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    mouse.x = e.clientX - rect.left;
    mouse.y = e.clientY - rect.top;
  });
  canvas.addEventListener('mousedown', e => { mouse.down = true; });
  canvas.addEventListener('mouseup', e => { mouse.down = false; });
  canvas.addEventListener('touchstart', e => {
    const rect = canvas.getBoundingClientRect();
    const touch = e.touches[0];
    mouse.x = touch.clientX - rect.left;
    mouse.y = touch.clientY - rect.top;
    mouse.down = true;
  });
  canvas.addEventListener('touchmove', e => {
    const rect = canvas.getBoundingClientRect();
    const touch = e.touches[0];
    mouse.x = touch.clientX - rect.left;
    mouse.y = touch.clientY - rect.top;
  });
  canvas.addEventListener('touchend', e => { mouse.down = false; });

  // Keyboard movement and tank color selection before game start
  window.addEventListener('keydown', e => {
    if (gameRunning) {
      keys[e.key.toLowerCase()] = true;
    } else {
      // Tank color selection with keys 1, 2, 3
      if (e.key === '1') selectTankColor(colorOptions.blue);
      else if (e.key === '2') selectTankColor(colorOptions.red);
      else if (e.key === '3') selectTankColor(colorOptions.green);
    }
  });
  window.addEventListener('keyup', e => {
    keys[e.key.toLowerCase()] = false;
  });

  // Color option selection UI handlers
  const colorBlue = document.getElementById('colorBlue');
  const colorRed = document.getElementById('colorRed');
  const colorGreen = document.getElementById('colorGreen');

  function selectTankColor(color) {
    tankColor = color;
    [colorBlue, colorRed, colorGreen].forEach(el => el.classList.remove('selected'));
    if (color === colorOptions.blue) colorBlue.classList.add('selected');
    else if (color === colorOptions.red) colorRed.classList.add('selected');
    else if (color === colorOptions.green) colorGreen.classList.add('selected');
    playBtn.disabled = false;
  }

  colorBlue.addEventListener('click', () => selectTankColor(colorOptions.blue));
  colorRed.addEventListener('click', () => selectTankColor(colorOptions.red));
  colorGreen.addEventListener('click', () => selectTankColor(colorOptions.green));

  // Play button handler
  playBtn.addEventListener('click', () => {
    if (!tankColor) return;
    startScreen.style.display = 'none';
    startGame();
  });

  // Upgrade base button
  upgradeBtn.addEventListener('click', () => {
    base.upgrade();
  });

  // Restart button
  restartBtn.addEventListener('click', () => {
    gameOverScreen.style.display = 'none';
    startScreen.style.display = 'block';
  });

  // Initial UI element for gameplay stats
  const ui = document.getElementById('ui');

  // Initial no selection disable play button
